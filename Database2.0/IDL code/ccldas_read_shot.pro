;+
; NAME:
; ccldas_read_shot
;
; PURPOSE:
; Read waveforms and metadata from an HDF5 file on a per-shot basis.
; 
; Can return all waveforms for a given shot, or only the one desired.
;
; CALLING SEQUENCE:
; (1) all_channels = ccldas_read_shot(file_id, shot_id)
; (2) only_one_channel = ccldas_read_shot(file_id, shot_id, 'first_detector')
;
; INPUTS:
; file_id: An hdf5 file reference generated by ccldas_file_open.
; shot_id: An integer shot ID; range is 0 through ccldas_get_nshots(file_id)-1
; 
; channel (kw, optional):  Name of the desired channel (string).  
;   Legal values are:
;   'first_detector'
;   'second_detector'
;   'final_detector'
;   'psu'
;   'lecroy_ch1'
;   'lecroy_ch2'
;   'lecroy_ch3'
;   'lecroy_ch4'
;   
; metadata (kw, optional):  Struct with velocity and mass estimates,
;   and machine parameters.  See below for definition.
; 
; OUTPUTS:
; (1) (all channels):  A struct with the following fields:
;   .first_detector       Waveform struct (see below) or -1 if not in file
;   .second_detector      Waveform struct (see below) or -1 if not in file
;   .third_detector       Waveform struct (see below) or -1 if not in file
;   .psu                  Waveform struct (see below) or -1 if not in file
;   .lecroy_ch1           Waveform struct (see below) or -1 if not in file
;   .lecroy_ch2           Waveform struct (see below) or -1 if not in file
;   .lecroy_ch3           Waveform struct (see below) or -1 if not in file
;   .lecroy_ch4           Waveform struct (see below) or -1 if not in file
;   
; (2) (channel specified):  A single waveform struct with the specified channel
; 
; METADATA STRUCT FIELDS:
; 
;   .velocity     Estimated velocity in m/s
;   .mass         Estimated mass in kg
;   .charge       Estimated charge in C
;   .radius       Estimated radius in m
;   
;   .timestamp          Integer with milliseconds in UNIX time
;   .dust_event         The (globally unique) dust event number (integer)
;   .group              The name of the experiment group (string)
;   .experiment_name    The name of the experiment (string)
;   
;   .passed               Did particle pass the final detector? (byte, 0/1)
;   .estimate_source      Program estimating v/m (0: Labview, 1: IDL estimator)
;   .estimate_quality     Quality indicator (integer)
;   
;   .high_voltage           Pelletron terminal voltage in MV
;   .control_high_voltage   Pelletron terminal voltage setpoint in MV
;   .vacuum_pressure        Beamline pressure in torr
;
;   .dust_type        Type of dust used
;   .dust_density     Density value for dust used               
;   
; WAVEFORM STRUCT FIELDS:
; 
;   .waveform       Array of single-precision floats with trace data
;   .dt             Time spacing of waveform points in seconds
;   .offset         Time value of first waveform point, in seconds
;   .hardware_id    Identifies the signal source: 1-6 for CSAs, 0 for other
;   
; MODIFICATION HISTORY:
; Written August 2012 by Spenser Burrows
; Updated 8/17/2012 by Andrew Collette: added docs & refactor
; Updated 7/15/2015 by Tobin Munsat: changed how dust_event_id is
; treated (now uses the actual dust event id, rather than a sequential
; number within a given hdf5 file).  This corresponds to the way that
; the hdf5 files are now written.
; ALSO removed attributes passed_third_detector and estimate_source,
; which are no longer saved in hdf5 files.
;-


function ccldas_read_shot, file_id, shot_id, channel=channel, metadata=metadata

  ON_ERROR, 2
  
  ; Argument validation
  
  channel_names = ['first_detector','second_detector','third_detector','lecroy_ch1','lecroy_ch2','lecroy_ch3','lecroy_ch4','psu']
  IF N_ELEMENTS(channel) NE 0 THEN BEGIN
    IF TOTAL(channel_names eq channel) EQ 0 THEN MESSAGE, "Invalid channel name.  Valid names are: "+STRJOIN(channel_names, ", ")
  ENDIF

  IF H5I_GET_TYPE(file_id) NE "FILE" THEN BEGIN
    MESSAGE, "Invalid file_id"
  ENDIF
  
  IF shot_id LT 0 || shot_id GE H5G_GET_NMEMBERS(file_id, '/') THEN BEGIN
    MESSAGE, "Shot ID must be between 0 and "+STRCOMPRESS(STRING(H5G_GET_NMEMBERS(file_id, '/')-1),/remove_all)
  ENDIF
  
  ; These are the names of the attributes stored in the file
  db_names = [  'velocity', $
                'mass', $
                'charge', $
                'radius', $
                $
                'integer_timestamp', $ ; TODO: change this in file to "timestamp"
                'id_dust_event', $     ; TODO: change this in file to "dust_event"
                'id_groups', $         ; TODO: change this in file to "group"
                'experiment_name', $
                'experiment_description', $
                $
;                'passed_3rd_detector', $ ;TODO: change this in file to "passed"
;                'estimate_source', $
                'estimate_quality', $
                $
                'high_voltage', $
                'control_high_voltage', $
                'vacuum_pressure', $
                'dust_type', $
                'dust_density' ]
                
  metadata = {  velocity: float(0), $
                mass: float(0), $
                charge: float(0), $
                radius: float(0), $
                $
                timestamp: long64(0), $
                dust_event: long64(0), $
                group: '', $
                experiment_name: '', $
                experiment_description: '', $
                $
;                passed: byte(0), $            ;removed 7/15/15 TLM
;                estimate_source: byte(0), $   ;removed 7/15/15 TLM
                estimate_quality: fix(0), $
                $
                high_voltage: float(0), $
                control_high_voltage: float(0), $
                vacuum_pressure: float(0), $
                dust_type: '', $
                dust_density: float(0)}

  dust_event_id = H5G_GET_OBJ_NAME_BY_IDX(file_id, STRCOMPRESS(STRING(shot_id),/REMOVE_ALL));inserted 7/8/15 TLM
  ;print
  ;print,'dust_event_id: '+s2(dust_event_id)
  ;;shot_group_id = H5G_OPEN(file_id,STRCOMPRESS(STRING(shot_id),/REMOVE_ALL));original, pre 7/15/15
  shot_group_id = H5G_OPEN(file_id, dust_event_id) ; inserted 7/8/15 TLM
  ;print,'shot_group_id: '+s2(shot_group_id)
  ;print

  
  ; Read metadata and populate struct
  FOR i=0, N_ELEMENTS(db_names)-1 DO BEGIN
    aid = H5A_OPEN_NAME(shot_group_id, db_names[i])
    metadata.(i) = H5A_READ(aid)
    H5A_CLOSE, aid
  ENDFOR
  
  first_detector = -1
  second_detector = -1
  third_detector = -1
  lecroy_ch1 = -1
  lecroy_ch2 = -1
  lecroy_ch3 = -1
  lecroy_ch4 = -1
  psu = -1

  signal_meta = { dt: float(0), hardware_id: fix(0), offset: float(0), signal_length: long(0) }
  signal_meta_names = STRLOWCASE(TAG_NAMES(signal_meta))
  
  ; Loop over each dataset in the group, and:
  ; (1) dump its attributes into signal_meta
  ; (2) dump the raw data into a waveform
  ; (3) place it in the correct variable
  FOR i=0, H5G_GET_NMEMBERS(shot_group_id,'.')-1 DO BEGIN
  
    dsname = STRLOWCASE(H5G_GET_OBJ_NAME_BY_IDX(shot_group_id, i))
    
    ; If only one channel is requested, don't bother reading all the data
    IF (N_ELEMENTS(channel) NE 0) && (dsname ne channel) THEN CONTINUE
    
    dsid = H5D_OPEN(shot_group_id, dsname)
    
    ; Dump attributes into signal_meta struct
    FOR ai=0, N_ELEMENTS(signal_meta_names)-1 DO BEGIN
      aid = H5A_OPEN_NAME(dsid, signal_meta_names[ai])
      signal_meta.(ai) = H5A_READ(aid)
      H5A_CLOSE, aid
    ENDFOR

    waveform = H5D_READ(dsid)
    
    H5D_CLOSE, dsid
    
    sm = signal_meta  ; easier to type

    ;help,sm
    ;result=get_kbrd()

    
    CASE dsname OF
      'first_detector':   first_detector =  { waveform: waveform, dt: sm.dt, offset: sm.offset, signal_length: sm.signal_length, hardware_id: sm.hardware_id}
      'second_detector':  second_detector = { waveform: waveform, dt: sm.dt, offset: sm.offset, signal_length: sm.signal_length, hardware_id: sm.hardware_id}
      'third_detector':   third_detector =  { waveform: waveform, dt: sm.dt, offset: sm.offset, signal_length: sm.signal_length, hardware_id: sm.hardware_id}
      'psu':              psu =             { waveform: waveform, dt: sm.dt, offset: sm.offset, signal_length: sm.signal_length, hardware_id: sm.hardware_id}
      'lecroy_ch1':       lecroy_ch1 =      { waveform: waveform, dt: sm.dt, offset: sm.offset, signal_length: sm.signal_length, hardware_id: sm.hardware_id}
      'lecroy_ch2':       lecroy_ch2 =      { waveform: waveform, dt: sm.dt, offset: sm.offset, signal_length: sm.signal_length, hardware_id: sm.hardware_id}
      'lecroy_ch3':       lecroy_ch3 =      { waveform: waveform, dt: sm.dt, offset: sm.offset, signal_length: sm.signal_length, hardware_id: sm.hardware_id}
      'lecroy_ch4':       lecroy_ch4 =      { waveform: waveform, dt: sm.dt, offset: sm.offset, signal_length: sm.signal_length, hardware_id: sm.hardware_id}
    ENDCASE
    
  ENDFOR ; End loop over datasets in the signal group

  
  H5G_CLOSE, shot_group_id
  
  ; Note these MUST be in the same order as channel_names or the extraction
  ; of a single channel by the channel= keyword won't work
  signals = CREATE_STRUCT('first_detector',first_detector,'second_detector',second_detector, 'third_detector',third_detector,'lecroy_ch1',lecroy_ch1,'lecroy_ch2',lecroy_ch2,'lecroy_ch3',lecroy_ch3,'lecroy_ch4',lecroy_ch4,'psu', psu)

  IF N_ELEMENTS(channel) NE 0 THEN BEGIN
    return, signals.(WHERE(channel_names eq channel))
  ENDIF
  
  return, signals
  
END
